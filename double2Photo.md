# План исправления обработки нескольких фотографий

## Проблемы1.  **Race condition** : При параллельной отправке двух фотографий оба запроса читают состояние одновременно (0 фото), каждый добавляет свою фотографию и сохраняет состояние с 1 фото, в результате вторая фотография теряется.

2. **Дублирование сообщений** : Каждая фотография вызывает отдельное сообщение "Ок, фото получено!", что создает дублирование.
3. **Логика проверки** : После второй фотографии все еще показывается "Got 1/2 photos" вместо "Got 2/2 photos".

## Решения

### 1. Исправление race condition в `<span class="markdown-lexical-editor-text-code">src/bot/handlers/photos.py</span>`* Использовать атомарную операцию чтение-модификация-запись через `<span class="markdown-lexical-editor-text-code">state.get_data()</span>` и `<span class="markdown-lexical-editor-text-code">state.update_data()</span>` с проверкой текущего состояния

* Добавить проверку максимального количества фотографий перед добавлением
* Улучшить логирование для диагностики

### 2. Оптимизация сообщений* Отправлять одно сообщение после обработки всех фотографий в одном обновлении (если Telegram отправляет несколько фото в одном сообщении)

* Или отправлять сообщение только после успешного сохранения состояния

### 3. Улучшение логики проверки количества фото* Убедиться, что состояние правильно сохраняется и читается

* Добавить валидацию количества фотографий перед переходом в следующее состояние

### 4. Поддержка нескольких фото в Gemini* Убедиться, что промпт для LLM правильно описывает задачу объединения нескольких товаров

* Проверить, что Gemini API получает все фотографии корректно

## Файлы для изменения1. `<span class="markdown-lexical-editor-text-code">src/bot/handlers/photos.py</span>` - исправление race condition и логики сохранения

1. `<span class="markdown-lexical-editor-text-code">src/services/llm_client.py</span>` - улучшение промпта для задач с несколькими товарами (опционально)

## Технические детали* Использовать `<span class="markdown-lexical-editor-text-code">await state.get_data()</span>` для чтения текущего состояния

* Проверять `<span class="markdown-lexical-editor-text-code">len(photos)</span>` перед добавлением новой фотографии
* Использовать `<span class="markdown-lexical-editor-text-code">await state.update_data(photos=photos)</span>` для атомарного обновления
